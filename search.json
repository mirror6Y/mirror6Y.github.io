[{"title":"搭建RocketMQ5.X","url":"/2024/01/20/搭建RocketMQ5.X/","content":"\n Local 模式，单组节点单副本模式\n\n镜像\n\napache/rocketmq:5.1.4\n\napacherocketmq/rocketmq-dashboard:latest\n\n准备工作\n\n安装docker和docker-compose\n\ndocker --version\n\ndocker-compose --version\n\n\n\n### 部署NameServer\n\n```\n# 日志目录\nmkdir /usr/local/rocketmq/nameserver/logs -p\n# 脚本目录\nmkdir /usr/local/rocketmq/nameserver/bin -p\n# 设置权限\nchmod 777 -R /usr/local/rocketmq/nameserver/*\n# 运行镜像\ndocker run -d \\\n--privileged=true \\\n--name rmqnamesrv \\\napache/rocketmq:5.1.4 sh mqnamesrv\n# 复制sh\ndocker cp rmqnamesrv:/home/rocketmq/rocketmq-5.1.4/bin/runserver.sh /usr/local/rocketmq/nameserver/bin/runserver.sh\n# 删除镜像\ndocker stop cbf91075c892\ndocker rm cbf91075c892\n# 启动namesrv\ndocker run -d \\\n--privileged=true \\\n--restart=always \\\n--name rmqnamesrv \\\n-p 9876:9876  \\\n-v /usr/local/rocketmq/nameserver/logs:/home/rocketmq/logs \\\n-v /usr/local/rocketmq/nameserver/bin/runserver.sh:/home/rocketmq/rocketmq-5.1.4/bin/runserver.sh \\\n-e \"MAX_HEAP_SIZE=256M\" \\\n-e \"HEAP_NEWSIZE=128M\" \\\napache/rocketmq:5.1.4 sh mqnamesrv\n```\n\nrunserver.sh注释掉动态方法\n\n![image-r-status.png](../images/image-r-status.png)\n\n### 部署Broker\n\n```\n# 创建需要的挂载目录（并在conf文件夹下创建broker.conf文件）\nmkdir /usr/local/rocketmq/broker/logs -p \nmkdir /usr/local/rocketmq/broker/data -p \nmkdir /usr/local/rocketmq/broker/conf -p \nmkdir /usr/local/rocketmq/broker/bin -p\n# 设置权限\nchmod 777 -R /usr/local/rocketmq/broker/*\n# 配置broker\nvi /usr/local/rocketmq/broker/conf/broker.conf\n```\n\nbroker.conf\n\n```\n# 集群名称\nbrokerClusterName = DefaultCluster\n# 节点名称\nbrokerName = broker-a\n# broker id节点ID， 0 表示 master, 其他的正整数表示 slave，不能小于0 \nbrokerId = 0\n# Broker服务地址\tString\t内部使用填内网ip，如果是需要给外部使用填公网ip，自行更改\nbrokerIP1 = 192.168.66.106\n# Broker角色\nbrokerRole = ASYNC_MASTER\n# 刷盘方式\nflushDiskType = ASYNC_FLUSH\n# 在每天的什么时间删除已经超过文件保留时间的 commit log，默认值04\ndeleteWhen = 04\n# 以小时计算的文件保留时间 默认值72小时\nfileReservedTime = 72\n# 是否允许Broker 自动创建Topic，建议线下开启，线上关闭\nautoCreateTopicEnable=true\n# 是否允许Broker自动创建订阅组，建议线下开启，线上关闭\nautoCreateSubscriptionGroup=true\n```\n\n\n\n\n\n```\n# 启动镜像\ndocker run -d \\\n--name rmqbroker \\\n--privileged=true \\\napache/rocketmq:5.1.4 \\\nsh mqbroker\n# 复制sh\ndocker cp rmqbroker:/home/rocketmq/rocketmq-5.1.4/bin/runbroker.sh /usr/local/rocketmq/broker/bin/runbroker.sh\n# 删除镜像\ndocker stop cbf91075c892\ndocker rm cbf91075c892\n# runserver.sh注释掉动态方法\n# 启动broker\ndocker run -d \\\n--restart=always \\\n--name rmqbroker \\\n-p 10911:10911 -p 10909:10909 -p 8081:8081 \\\n--privileged=true \\\n-v /usr/local/rocketmq/broker/logs:/root/logs \\\n-v /usr/local/rocketmq/broker/store:/root/store \\\n-v /usr/local/rocketmq/broker/conf/broker.conf:/home/rocketmq/broker.conf \\\n-v /usr/local/rocketmq/broker/bin/runbroker.sh:/home/rocketmq/rocketmq-5.1.4/bin/runbroker.sh \\\n-e \"MAX_HEAP_SIZE=512M\" \\\n-e \"HEAP_NEWSIZE=256M\" \\\napache/rocketmq:5.1.4 \\\nsh mqbroker -c /home/rocketmq/broker.conf -n 192.168.66.106:9876 --enable-proxy \n```\n\nrunserver.sh注释掉动态方法\n\n查看启动状态\n\n```\ndocker exec -it rmqbroker bash -c \"tail -n 10 /home/rocketmq/logs/rocketmqlogs/proxy.log\"\n```\n![r-imgage.png](../images/r-image.png)\n\n### 部署Dashboard\n\n-Drocketmq.namesrv.addr地址使用自己的\n\n```\ndocker run -d \\\n--restart=always \\\n--name rmqdashboard \\\n-e \"JAVA_OPTS=-Xmx256M -Xms256M -Xmn128M -Drocketmq.namesrv.addr=192.168.66.106:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false\" \\\n-p 6080:8080 \\\napacherocketmq/rocketmq-dashboard\n```\n\n### docker-compose部署\n\n```\ncd /usr/local/rocketmq\nvi docker-compose.yml\n```\n\n配置\n\n```\nversion: '3.8'\nservices:\n  rmqnamesrv:\n    image: apache/rocketmq:5.1.4\n    container_name: rmqnamesrv\n    ports:\n      - 9876:9876\n    restart: always\n    privileged: true\n    volumes:\n      - /usr/local/rocketmq/nameserver/logs:/home/rocketmq/logs\n      - /usr/local/rocketmq/nameserver/bin/runserver.sh:/home/rocketmq/rocketmq-5.1.4/bin/runserver.sh\n    environment:\n      - MAX_HEAP_SIZE=256M\n      - HEAP_NEWSIZE=128M\n    command: [\"sh\",\"mqnamesrv\"]\n  broker:\n    image: apache/rocketmq:5.1.4\n    container_name: rmqbroker\n    ports:\n      - 10909:10909\n      - 10911:10911\n      - 8081:8081\n    restart: always\n    privileged: true\n    volumes:\n      - /usr/local/rocketmq/broker/logs:/home/rocketmq/logs\n      - /usr/local/rocketmq/broker/store:/home/rocketmq/logs\n      - /usr/local/rocketmq/broker/conf/broker.conf:/home/rocketmq/broker.conf\n      - /usr/local/rocketmq/broker/bin/runbroker.sh:/home/rocketmq/rocketmq-5.1.4/bin/runbroker.sh\n    depends_on:\n      - 'rmqnamesrv'\n    environment:\n      - NAMESRV_ADDR=rmqnamesrv:9876\n      - MAX_HEAP_SIZE=512M\n      - HEAP_NEWSIZE=256M\n    command: [\"sh\",\"mqbroker\",\"-c\",\"/home/rocketmq/broker.conf\",\"--enable-proxy\"]\n  rmqdashboard:\n    image: apacherocketmq/rocketmq-dashboard:latest\n    container_name: rocketmq-dashboard\n    ports:\n      - 600:8080\n    restart: always\n    privileged: true\n    depends_on:\n      - 'rmqnamesrv'\n    environment:\n      - JAVA_OPTS= -Xmx256M -Xms256M -Xmn128M -Drocketmq.namesrv.addr=rmqnamesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false\n```\n\n```\n# docker Compose v2版本命令 #  -d 指后台运行\ndocker compose up -d \n# docker Compose v1版本命令 #  -d 指后台运行\ndocker-compose up -d\n```\n\n访问： http://192.168.66.106:6080/\n\n![image-r-Dashboard.png](../images/image-r-Dashboard.png)","tags":["RocketMQ"],"categories":["中间件"]},{"title":"飞猪面试收获","url":"/2023/02/08/飞猪-面试收获/","content":"\n2023年2月份有在boss上投递简历到飞猪公司，业界对飞猪的评价也是褒贬不一。有人说飞猪在22年裁了很多人，业绩下滑；有人说飞猪是外包，集团的外环；有人说飞猪要从阿里独立，签约新主体。我呢，更多是抱着学习的心态去面试的。以我目前的实力，要通过面试还是有难度的。\n\n首先和面试官简单聊了聊在前东家的负责的业务和项目，描述的过程中我发现项目没有什么亮点，没有可以去炫耀的内容。怎么样才能有一个拿得出去的作品？可能开源项目是一个不错的选择。然后面试官又问我是否了解CMS和G1的区别，我以之前了解过忘记了为由结束了这个问题。每次面试需要看的八股文多如牛毛，背下来过了一段时间又忘记了，忘记了再去背，好像进入了循环。接着面试官问我是否处理过关于JVM的线上问题，其实我处理过一次内存溢出的问题，但是时间间隔太久，调优的参数我都忘记是哪个了，着实让我尴尬，回答的不是很好。最后让我说一说Redis的I/O模型，我先解释了一下多路复用I/O模型，然后说连接请求的流程时被面试官打断了，问我为什么Redis的事件驱动模型这么快。听到这个问题后，我陷入了沉思。我发现我只知道Redis事件驱动模型是怎么运作的，什么执行流程，但是不知道为什么这么快。Game Over！\n终于来到了最后一个环节，你有什么想对我说的。我请教了一个问题，我在学习Redis的原理的过程中发现我对Redis的认知还停留在表面，我了解它的运行机制，但是无法继续深入。面试官说他知道我有了解Redis的原理，但是没有把这些知识变成自己的。可以试着把学过的知识变成自己的，举一反三。在飞猪使用Redis也很少涉及到底层原理，日常也是拧螺丝，但是遇到问题的时候是否可以借鉴一下Redis的I/O模型是他们看重的。\n\n这次面试于我而言是很有收获的，每个框架、中间件的知识点都很多，如何做到把知识变成自己的，融会贯通，举一反三才是难得的。面试如此，生活亦是如此。\n","tags":["飞猪"],"categories":["面试"]},{"title":"Redis的I/O模型","url":"/2022/10/20/Redis的IO模型/","content":"\n一次 I/O 的读取请求分为两个阶段：\n- 等待内核空间准备数据\n- 数据从内核空间拷贝到用户空间\n\n《Unix网络编程》根据这两个阶段的不同把 I/O 分成了以下五种 IO 模型：\n![阻塞I/O.jpeg](https://s2.loli.net/2023/02/02/sZimCHdFTUAb7pw.jpg)\n\n## 网络I/O模型\n### 阻塞I/O\n![阻塞I/Ojpg](https://s2.loli.net/2023/02/02/KdJDPfXC52olFvZ.jpg)\n\n用户线程发起读取请求、等待内核空间准备数据、内核空间将数据拷贝到用户空间并返回给用户线程，这个过程用户线程一直处于等待的过程，不能处理其他任务。等待数据准备的阶段和拷贝数据的阶段都是阻塞的。\n如果有其他用户线程发起请求，那么这些线程会排队等待，等前面的线程处理完再处理后面的线程。\n\n总结：适合用户线程数量不高的情况。如果用户线程数量过高， CPU 一次只处理一个线程，会影响 CPU 的性能。\n优化：既然单线程效率低下，那么引入多线程进行优化怎么样？多线程可以解决 CPU 一次只能处理一个线程的问题，线程池也可以缓解一部分压力，但是用户线程的数量达到成千上万的时候，还是会有问题。因为线程池的维护也需要成本，比如线程的创建、销毁，上下文的切换，并不能从根本上解决问题。\n\n### 非阻塞I/O\n![非阻塞I/O.jpg](https://s2.loli.net/2023/02/02/vVfqrLcl1HAB8hG.jpg)\n\n用户线程发起读取请求，然后不断询问内核空间数据是否准备就绪。如果没有，用户线程会一直询问，直到内核空间数据准备就绪，然后内核空间将数据拷贝到用户空间并返回给用户线程。拷贝数据的阶段是阻塞的。\n\n总结：用户线程可以在等待数据的准备阶段处理其他的任务，但是需要不断询问内核空间数据是否已经准备就绪，从而导致 CPU 资源浪费，并且轮询之间的时间间隔会导致数据的延迟。\n\n### 多路复用I/O\n![多路复用I/O.jpg](https://s2.loli.net/2023/02/02/2aK73bNUfOcvDdi.jpg)\n\n> 多路是指网络连接，复用指的是同一个线程\n\n用户线程调用 select 函数，然后 select 会对用户线程进行监听，不断询问内核空间用户线程的数据是否准备就绪，如果用户线程的数据准备就绪，会通知对应的用户线程。然后用户线程发起读取数据的请求，内核空间将数据拷贝到用户空间并返回给用户线程。\n用户线程调用 select 函数之后，用户线程不会阻塞，但是select有可能阻塞，拷贝数据的阶段是阻塞的。\n\n总结：一个 select 函数可以同时监听多个用户线程，可以同时处理多个请求，从而提高 CPU 的效率。\n\n> 文件描述符（File Description）：简称FD，是一个从0开始递增的无符号整数，用来关联Linux系统中的一个文件。在Linux系统中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。\n\n对 Linux 来说，一个用户线程相当于一个 FD 。\n\nI/O 多路复用的实现有三种：\n* select\nselect 不知道哪个 FD （用户线程）的数据准备就绪，所以会轮询所有的 FD ，性能随着 FD 数量的增加而下降。底层采用了数组，支持的 FD 数量有限，最多1024个。每次 select 都要把监听的所有 FD 拷贝到内核空间，影响效率。 windows 系统只支持这种方法， linux 系统也支持。\n* poll\npoll 和 select 实现类似，不过它底层采用了链表，支持的 FD 数量是没有限制。 linux 系统支持。\n* epoll\nepoll 底层采用了红黑树，理论上 FD 的数量是没有限制的，而且 CURD 的效率都很高，性能不会随着 FD 数量的增加而下降。 epoll 会将就绪的 FD 放到一个链表里，不用轮询所有的 FD 。\n\n### 信号驱动I/O\n![信号驱动I/O.jpg](https://s2.loli.net/2023/02/02/EL8V7xtTevlBNOy.jpg)\n\n用户线程发起读取请求前先建立一个信号函数说明它需要读取哪些数据，然后内核空间收到信号后并返回。内核空间数据就绪后会返回信号，信号函数进行处理。然后用户线程再发起读取请求，内核空间将数据拷贝到用户空间并返回给用户线程。拷贝数据的阶段是阻塞的。\n\n总结：用户线程过多的时候，产生的信号也很多， sigal 函数不能及时处理会导致信号队列溢出。其次用户空间和内核空间信号的频繁交互导致性能较低。在 Java 技术体系中使用场景很少。\n\n### 异步I/O\n![异步I/O.jpg](https://s2.loli.net/2023/02/02/WoIZkKu6QTwhiyJ.jpg)\n\n用户线程发起读取请求，然后立即返回，用户线程可以处理其他的任务。内核空间接收到读取请求后，先准备数据，数据就绪后，内核空间将数据拷贝到用户空间并返回给用户线程。等待数据准备的阶段和拷贝数据的阶段都是不阻塞的。\n\n总结：异步 I/O 模型是效率最高的，也是最理想的。不过它的实现比较复杂，高并发场景应用还不够广泛，不够成熟。 Netty 曾尝试使用异步 I/O 模型，但是性能没有太多的提升就放弃了。\n\n## Redis的I/O模型\n\nRedis 采用的是多路复用模型，基于 Reactor 模式设计的事件驱动模型。\nRedis 中的事件分为两种：\n- 文件事件： Redis 服务器和客户端之间的网络 I/O ，比如连接、读取、写入等。\n- 时间事件： Redis 服务器有一些定时任务，比如持久化。\n\n### 文件事件\n![文件事件.jpg](https://s2.loli.net/2023/02/02/1hFjYZ7oWscAlzw.jpg)\n\nsocket 指的是客户端的连接、读取、写入等请求，本质上是一个 FD；\nI/O 多路复用程序负责创建，监听 FD ，绑定事件；\n事件分发处理器根据事件类型将事件转发给对应的处理器；\n处理器负责执行具体事件对应的任务操作。\n\n#### 连接请求\n![连接请求.jpg](https://s2.loli.net/2023/02/02/eXgIltwU6Trf5VH.jpg)\n\n有 client socket 连接 server sokcet 的时会产生  ae_readable 事件，然后多路复用程序会创建 ssFD 并绑定 ae_readable 事件，根据事件类型转发给连接应答处理器。连接应答处理器接收 client socket 并创建 client socket FD（FD），然后由多路复用程序对其进行监听。\n\n#### 命令请求\n![UML 图 (7).jpg](https://s2.loli.net/2023/02/02/EYzq5lPtXkZbhMo.jpg)\n\nclient socket 执行 set 命令 时会产生 ae_readable 事件，然后多路复用程序会创建 FD 并绑定 ae_readable 事件，根据事件类型转发给命令请求处理器。命令请求处理器读取 FD 的数据，解析命令，与FD ae_writeable 事件进行绑定，然后由多路复用程序对其进行监听。（黄色背景）\n多路复用程序监听到 FD 的 ae_writeable 事件后，根据事件类型转发给命令回复处理器。命令回复处理器将数据写入并返回 client socket 。（绿色背景）\n\n\n### 时间事件\nRedis 将所有时间事件都放在一个无序链表中，每次 Redis 会遍历整个链表，查找所有已经到达的时间事件，并且调用相应的事件处理器。\n\n\n参考资料：\n\n[掘金](https://juejin.cn/post/6882984260672847879#heading-7)\n[B站黑马](https://www.bilibili.com/video/BV1cr4y1671t?p=171&vd_source=5ecb21a9c2d5bed6b9e12a0726087431)","tags":["Redis"],"categories":["中间件"]},{"title":"计算机编码","url":"/2021/06/20/计算机编码/","content":"\n了解计算机编码之前，首先要清楚比特（bit）和字节（byte）的概念。\n\n​在计算机内部，所有信息都是由二进制位0和1组成的，比特代表从二进制数组中选出一元（0或1）所提供的的信息，所以比特（bit）也是信息的最小单位。字节（byte）是二进制数据的单位，一个字节（byte）为8个比特。数据传输大多以比特（bit）为单位，通常简写为小写“b”；而数据存储是以字节（byte）为单位，通常简写为“B”。\n\n​我们在使用windows系统下载软件的时候偶尔会有32位，64位的选项，你知道这是什么意思吗？\n\n​在计算机中，一串数码作为一个整体来处理或运算的，称为一个计算机字，简称字（word）。字通常分为若干个字节（每个字节一般是8位）。在存储器中，通常每个单元存储一个字。因此每个字都是可以寻址的。字的长度用位数来表示。\n\n​计算机的每个字所包含的位数称为字长，计算的字长是指它一次可处理的二进制数字的数目。一般地，大型计算机的字长为32-64位，小型计算机为12-32位，而微型计算机为4-16位。字长是衡量计算机性能的一个重要因素。\n\n## ASCII\n\n​在计算机中所有的数据都是二进制位表示的，所以英语的单词，汉语的汉字等都要转换成对应的二进制数据。这个时候就需要一套二进制与字符对应的编码。\n\n​ASCII是美国提出的一套基于拉丁字母的编码标准，主要用于显示现代英语和其他西欧语言。到目前为止，一共定义了128个字符。二的七次幂。\n\n## ASCII的问题\n\n> 在英语中，用128个符号编码便可以表示所有，但是用来表示其他语言，128个符号是不够的。比如，在[法语]（https://baike。baidu。com/item/法语/660115）中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号 [5] 。\n>\n> 但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在[法语]（https://baike。baidu。com/item/法语/660115）编码中代表了é，在[希伯来语]（https://baike。baidu。com/item/希伯来语/2612441）编码中却代表了字母Gimel （ג），在[俄语]（https://baike。baidu。com/item/俄语/315852）编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段 [5] 。\n>\n> 至于[亚洲]（https://baike。baidu。com/item/亚洲/133681）国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 [GB2312]（https://baike。baidu。com/item/GB2312/483170），使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号 [5] 。\n\n## GB2312和GBK\n\n​由于ASCII不是所有国家都可以使用的编码标准，所以欧洲有提出ISO/IEC 8859-1标准，我国也有提出GB2312和GBK。\n\n​GB2312编码适用于汉字处理和汉字通信等系统之间的信息交换，通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持GB2312。不过对于人名，古汉语中出现的生僻字，GB2312是不能处理的，所以后来又发布了GBK。\n\n## Unicode\n\n​前面提到的ASCII和GBK都属于\"方言\"，同一个二进制数字可以被解释成不同的字符。如果中国人给美国人发送email，在中国发送的\"你好\"是正常的，但是在美国解析会出现乱码。这个时候就需要一种统一的标准。\n\n​Unicode出现了，它是世界各国合作开发的一种业界<span style=\"background-color:yellow\">是标准</span>。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。\n\n## Unicode的问题\n\n> 需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。\n>\n> 比如，汉字`严`的 Unicode 是十六进制数`4E25`，转换成二进制数足足有15位（`100111000100101`），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。\n>\n> 这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是`0`，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。\n>\n> 它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。\n\n## UTF-8\n\n​互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的<span style=\"background-color:yellow\">实现方式</span>。\n\n> UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n>\n> UTF-8 的编码规则很简单，只有二条：\n>\n> 1）对于单字节的符号，字节的第一位设为`0`，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。\n>\n> 2）对于`n`字节的符号（`n > 1`），第一个字节的前`n`位都设为`1`，第`n + 1`位设为`0`，后面字节的前两位一律设为`10`。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。\n>\n> 下表总结了编码规则，字母`x`表示可用编码的位。\n>\n> > ```\n> > Unicode符号范围      |        UTF-8编码方式\n> > （十六进制）            |       （二进制）\n> > --------------------+---------------------------------------------\n> > 0000 0000-0000 007F | 0xxxxxxx\n> > 0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n> > 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n> > 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n> > ```\n>\n> 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是`0`，则这个字节单独就是一个字符；如果第一位是`1`，则连续有多少个`1`，就表示当前字符占用多少个字节。\n>\n> 下面，还是以汉字`严`为例，演示如何实现 UTF-8 编码。\n>\n> `严`的 Unicode 是`4E25`（`100111000100101`），根据上表，可以发现`4E25`处在第三行的范围内（`0000 0800 - 0000 FFFF`），因此`严`的 UTF-8 编码需要三个字节，即格式是`1110xxxx 10xxxxxx 10xxxxxx`。然后，从`严`的最后一个二进制位开始，依次从后向前填入格式中的`x`，多出的位补`0`。这样就得到了，`严`的 UTF-8 编码是`11100100 10111000 10100101`，转换成十六进制就是`E4B8A5`。\n\nUnicode 与 UTF-8 之间是可以转换的，有兴趣的话可以研究\n\n*参考文章:http://www。ruanyifeng。com/blog/2007/10/ascii_unicode_and_utf-8。html*\n","tags":["编码"],"categories":["编码"]},{"title":"折耳根，从入门到放弃","url":"/2021/05/10/折耳根，从入门到放弃/","content":"\n说起折耳根，可能很多人不知道它是什么，但是鱼腥草你可能就听说过了。我把百度百科对它的描述贴在了下面。\n\n> 蕺菜（拉丁学名：Houttuynia cordata Thunb）折耳根（名医别录）、鱼腥草（本草纲目）、狗贴耳（广东梅州市梅县区）、折耳根（四川、云南、贵州）、猪鼻拱（四川） 。腥臭草本植物，有异味。叶片心形，托叶下部与叶柄合生成鞘状。穗状花序在枝顶端与叶互生，花小，两性，总苞片白色，花丝下部与子房合生，子房上位。蒴果卵圆形，花果期5～10月。\n>\n> 阴性植物，怕强光，喜温暖潮湿环境，较耐寒，-15℃可越冬，忌干旱，以肥沃的砂质壤土或腐殖质壤土生长最好。农田常见杂草，生果园、茶园、路埂等。产区：陕西、甘肃及长江流域以南各省，以及日本、印度尼西亚爪哇岛。\n\n再瞧瞧它的真实面貌~\n\n![折耳根.jpg](https://s2.loli.net/2022/10/31/LlPiGybNOuDa2jo.jpg)\n\n哇，这看着真的很有食欲，有没有？必须啊，吃了折耳根你就可以和云贵朋友的关系更上一层楼。亲身体验。\n\n作为一个东北孩子，在老家是接触不到折耳根的，那我又是如何从吃折耳根到放弃的一个过程呢？这要从我大学认识的一位遵义的朋友说起，不知道遵义在哪里的读者，可以去看看地图补一补常识。（遵义是贵州的地级市。）遵义会议，应该晓得吧？那可是我党历史上的一个重要转折点，纠正了一些的“左”倾错误，挽救了党，挽救了红军，挽救了中国革命。还有......\n\n![表情包.jpg](https://s2.loli.net/2022/10/31/ZteEOUMaVxWowbg.webp)\n\n不好意思，有点跑题。回到我遵义朋友这件事。这位朋友在一次聊天的时候发了张折耳根凉菜的图片，深深的吸引了我，擦一擦嘴边的口水。但是我听说很多人是不会吃折耳根的，因为它有一股独特的气味。\n\n不过本人喜欢尝试一些新鲜独特的食物，比如螺蛳粉、臭豆腐，榴莲等。于是在一次吃串串的时候，我看到了折耳根，便尝试了，还是可以接受的，没有传说中那么恐怖，也算折耳根入门了。\n\n![image.png](https://s2.loli.net/2022/10/31/VLuGytbR1YNI54n.png)\n\n今年五一的时候，我决定去贵阳看看那个遵义的朋友（暂且称他为Alan同学），再感受一下祖国的大好河山，顺便尝一尝当地的美食。我从杭州出发，历时八小时，屁颠屁颠地，终于在晚上到了贵阳。\n\n饿了好几个小时，吼吼，总算可以吃饭了。Alan安排了贵阳小烧烤，苕皮，冰粉等等。但是我这次吃折耳根的时候和第一次的感觉完全不同，会有一点腥腥的味道，不过还可以下咽，也许是辣椒比较多的缘故。贵州和川渝一样，饮食相对比较辣，可谓无辣不欢。对我来说，也是一种考验。\n\n第二天从黔灵山公园的人山人海中挤出来之后，Alan同学带我去了丝娃娃餐馆。丝娃娃是贵阳的特色美食，来了一定要品尝。还有脑花，串串，面皮，都很不错。\n\n![F767A468-216C-4408-A170-F3E7E1E60340_1_105_c.jpeg](https://s2.loli.net/2022/10/31/vADF5W2EK6cm8rT.jpg)\n\n不过，所有的菜里面默认都放了折耳根，在贵阳，折耳根和葱花香菜一样是一种调味品。我在吃折耳根的时候有点难以下咽，因为这股腥腥的味道十分强烈，我受不了了。\n\n\n![image.png](https://s2.loli.net/2022/10/31/iW6bxIwStGRr3P2.png)\n\n艾玛，这真的是神仙味道啊，以后再也不吃了，为此我还被Alan嘲笑一番。\n\n第三天我们去了成都，看了人山人海。旅游一定一定一定要错开人流，我亲爱的读者朋友们。否则，时间都花费在排队上面了。\n\n最后呢，我想说：祖国地大物博，山川秀丽，希望大家可以去外面的城市看一看；同时感谢Alan同学的盛情款待~","tags":["折耳根"],"categories":["旅游"]}]